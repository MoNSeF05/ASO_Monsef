# Administración de procesos del sistema
Todo software ejecutable, incluido el mismo sistema operativo, se acaba constituyendo en una serie de unidades llamadas procesos que se organizan, ordenan y consumen recursos, para acabar siendo ejecutados por el procesador. La administración de estos procesos y
de sus recursos asociados constituye una de las tareas básicas y primordiales del núcleo del sistema operativo que, entre otros, comprenderá funciones como por ejemplo:

- La creación y destrucción de procesos
- El despacho (dispatcher), es decir, la asignación de procesos ejecución en el procesador
- Los cambios de estado que denominamos transiciones
- La suspensión y reanudación de procesos
- La sincronización de procesos
- La comunicación entre procesos
- La manipulación de bloques de control de proceso (PCB)

Muchas de estas actividades están solo en manos del sistema operativo y serán transparentes para el usuario, pero hay que conocer bien los mecanismos de la administración de procesos, puesto que el usuario puede intervenir en aspectos cruciales como por ejemplo la configuración del arranque del sistema, la asignación de prioridades o la finalizando, suspensión y reanudación de estos procesos.

## Conceptos básicos sobre procesos

Un proceso es la instancia de un programa en ejecución que necesita para realizar su tarea recursos como por ejemplo:
* Tiempo de procesador
* Memoria
* Archivos
* Dispositivos de entrada/salida

Estos recursos se pueden asignar en el momento de la creación del proceso o bien durante su ejecución.
Desde esta perspectiva, un proceso se puede considerar unas líneas de código cargadas a memoria y un contexto asociado constituido por la actividad del procesador en un momento determinado, es decir:
* El valor del contador del programa
* El contenido de los registros del procesador y por una serie de datos almacenados a la memoria

### Concepto de Aplicación, Proceso y Servicio

Se considera generalmente una **aplicación informática** como un programa diseñado para interaccionar con el usuario, por lo tanto se ejecuta en primer plan (foreground) con una determinada interfaz de usuario. Son ejemplos típicos de aplicaciones los programas de ofimática, los navegadores, los reproductores multimedia, etc.

En cambio, un **servicio** es un término que corresponde al concepto y funcionalidad del demonio (daemon) en la terminología de Linux. Denominamos servicio en un programa normalmente asociado al sistema operativo, aunque también se puede poner en marcha de forma manual, y que trabaja en segundo plan (background) sin interfaz de usuario, apoyando a otros programadores. Los servicios proporcionan prestaciones como servicios de páginas web, registro de acontecimientos, servicios de impresión, criptografía…

El concepto de **proceso**, en cambio, tiene más a ver con el funcionamiento interno del sistema operativo y consiste en una serie de instrucciones alojadas a la memoria que, mediante colas y un mecanismo de planificación, acceden a la CPU para ejecutarse. Así, pues, cuando se pone en marcha cualquier aplicación o servicio genera uno o más procesos en el sistema.

### Tipos de procesos y su clasificación

Podemos hacer algunas clasificaciones de los procesos en función de su propietario, su comportamiento en concurrencia, la forma de ejecución y ubicación a la memoria o los recursos del sistema que compartan.

#### Según del propietario del proceso

* Procesos de sistema: Asociados al funcionamiento del núcleo del sistema o de los diferentes servicios en funcionamiento (demonios). Muchos de estos procesos están asociados a usuarios virtuales del sistema (lp, www, mail, etc.).
* Procesos de superusuario: Asociados a la cuenta de la administrador raíz (root).
* Procesos de usuario: Asociados a la ejecución de aplicaciones de un usuario determinado.

#### Según la concurrencia del proceso
- Independientes: No afectan ni son afectados por otros procesos.
- Cooperantes: Pueden compartir datos y por tanto afectar y ser afectados por otros procesos.

#### Según la forma de ejecución y ubicación a la memoria

- Residentes: Los procesos residentes son siempre en la memoria mientras dura la ejecución.
- Intercambiables: Pueden ser llevados de la memoria principal al disco duro mientras están bloqueados. Así, la memoria liberada puede ser utilizada por otros procesos que la necesiten.

#### Según los recursos que comparten
+ Pesados: Los procesos pesados son independientes y tienen todos sus propios recursos.
+ Ligeros: También llamados hilos de ejecución o threads, comparten entre sí espacio de memoria y recursos de entrada y salida.


### Planificación de procesos

Tal como hemos avanzado, una de las obligaciones de un sistema operativo como gestor de procesos es la planificación de procesos: la ejecución de múltiples procesos optimizando el uso del procesador.

Así, pues, las políticas de planificación de procesos surgen como necesidad de cumplir dos de los principales objetivos funcionales de los sistema operativo: la multiprogramación y el tiempo compartido:

+ **Multiprogramación**: Tiene como objetivo maximizar el aprovechamiento de la CPU teniendo siempre en ejecución algún proceso en todo momento.
+ **Tiempo compartido**: Dado que una CPU solo puede realizar un proceso a la vez se trata de establecer un sistema de conmutación de la CPU entre los procesos con tal frecuencia que el usuario pueda interactuar y tenga la impresión que se están ejecutando en paralelo.

La planificación de procesos se desarrolla a tres niveles: largo, medio y corto plazo.

#### Planificación a largo plazo

El planificador a largo plazo es el encargado de crear los procesos determinando qué trabajos se admiten en el sistema para su procesamiento y cargándolos en la memoria disponible. Los sistemas operativos de tiempo compartido casi no tienen algoritmo de planificación a largo plazo y se limitan a crear y poner en estado “preparado” cualquier proceso nuevo. En cambio, tiene más sentido la planificación a largo plazo en sistemas que admiten procesamiento en lotes, puesto que es conveniente compensar tareas que pidan más tiempo de procesador con tareas que pidan más operaciones de entrada y salida, para equilibrar así los recursos del sistema.

#### Planificación a medio plazo

La planificación a medio plazo regula el grado de multiprogramación fijado en un principio por el planificador a largo plazo. Si el sistema no tiene suficientes recursos, en especial de memoria, para atender todos los procesos en marcha, se pueden pasar algunos de ellos en el estado de suspensos y liberar así recursos y memoria interna.

Para hacer esto es usa la técnica del intercambio (swapping, en inglés), que se encarga de suspender procesos enviándolos a memoria secundaria, habitualmente el disco duro (swap out), y reactivándolas posteriormente, volviéndolos a cargar de la memoria secundaria a la memoria interna (swap in).

>**Grado de multiprogramación**
>
>Corresponde al número de procesos activos en un momento determinado, que están cargados a la memoria principal del sistema.

#### Planificación a corto plazo

El planificador a corto plazo o dispatcher tiene la tarea esencial de decidir qué proceso pasa a ejecución de entre los que están a la cola de los procesos preparados (ready). Para hacer esta tarea, los planificadores a corto plazo implementan una serie de algoritmos que tienen como objetivo optimizar la eficiencia, la productividad y el tiempo de respuesta de la CPU.

Estos algoritmos de planificación se pueden clasificar en algoritmos apropiativos y no apropiativos, y también tenemos que considerar otras técnicas combinadas, como por ejemplo las colas multinivel.

**Algoritmos no apropiativos**

El sistema operativo no expulsa nunca el proceso de la CPU hasta que este acaba la ejecución o sale voluntariamente, por ejemplo, cuando el proceso pasa a bloqueado al inicio de una operación de entrada/salida. Ejemplos de estos tipos de algoritmo pueden ser:

>**Colas FIFO y LIFO**
>
>En una cola FIFO (first input first output) los elementos de la cola salen en el mismo orden que han entrado, mientras que en una cola LIFO (last input first output), también llamada pila o stack, es el último elemento llegado lo primero que sale de la cola.

* **FCFS** *(first come first served)*. Es una cola FIFO que da preferencia según la orden de llegada a la cola.
* **SJF** *(shortest job first)*. Algoritmo no apropiativos donde la prioridad de acceso a la ejecución depende del tiempo de ráfaga de CPU necesario. Así, se benefician aquellos procesos más cortos de ejecutar y se maximiza el número de procesos ejecutados por unidad de tiempo.

**Algoritmos apropiativos**

El sistema operativo puede decidir expulsar un proceso de la CPU y ejecutar otro. Algunos ejemplos de este tipo de algoritmo:

* **Round Robin:** Algoritmo de rueda en el cual el sistema operativo asigna un tiempo determinado a cada proceso. Este tiempo, llamado **quantum**, puede ser constante o calcularse dinámicamente. El proceso abandona la CPU cuando agota su quantum. La elección del valor del quantum es muy importante, puesto que un quantum muy pequeño produce demasiados cambios de contexto.
* **SRTN** *(shortest remaining time next)*: Algoritmo dependiente del tiempo de ráfaga como la SJF, pero en este caso es apropiativos. Es decir, si llega un nuevo proceso a la cola de preparados y su tiempo de ejecución es menor que el que le resta al que se está ejecutando en aquel momento, se puede apropiar de la CPU y expulsarlo.

**Colas multinivel**

Consisten en diferentes colas de procesos en estado de preparados. Cada cola tiene su prioridad. Para acceder a la ejecución en el procesador se escoge el proceso de la cola más prioritaria que no esté vacía. Dentro de cada cola se puede aplicar una política y un algoritmo de planificación diferente.

**Colas multinivel realimentadas**

Es el mismo caso de las colas multinivel, pero los procesos pueden avanzar y retroceder por las diferentes colas de prioridades. Por ejemplo, un proceso de prioridad alta que agote su quantum podría pasar a una cola de preparados de menos prioridad.

>El sistema operativo Unix/Linux usa colas multinivel realimentadas utilizan el algoritmo Round Robin a cada cola. Cada segundo se recalculan las prioridades de los procesos en función de unas prioridades dinámicas y de unas de fijas, definidas por un lado por el sistema, según el tipo de proceso, y de la otra por el mismo usuario mediante la configuración de la prioridad *nice*.


### Estados y transiciones de los Procesos


Una característica fundamental de un proceso es el estado en el cual se encuentra, que viene definido por su incorporación dentro de las diferentes colas que organizan la gestión del procesador. Una primera aproximación nos da hasta cinco estados diferentes posibles para un proceso, aunque la incorporación del sistema de intercambio (swapping) nos aportará dos posibles estados adicionales.

#### Estados de un proceso

Los cinco estados básicos de un proceso son los siguientes:

* Nuevo *(new)*: El proceso se está creando.
* Preparado *(ready)*: El proceso está a la cola, preparado para la asignación de un procesador.
* En ejecución *(running)*: Las instrucciones del proceso están siendo ejecutadas por el procesador.
* Bloqueado *(waiting)*: El proceso está parado en espera de un acontecimiento que lo desbloquee (finalización de una entrada/salida, recepción de una señal, etc.).
* Finalizado *(terminated)*: El proceso está finalizado y se liberan los recursos que usaba.

#### Transiciones de los procesos

Un proceso es un elemento esencialmente dinámico que va cambiando entre los diferentes estados mediante transiciones. Partiendo de un modelo de cinco estados como los que hemos definido, las posibles transiciones entre estados son las siguientes:

* **Nuevo → preparado**: el sistema está preparado para admitir un nuevo proceso porque dispone de recursos suficientes.
* **Preparado → ejecución**: el planificador a corto plazo, siguiendo diferentes algoritmos de planificación (Round Robin, SFJ, SPN, FCFS, etc.) decide cuál de los procesos en cola de preparados pasa a ejecución.
* **Ejecución → preparado**: si el algoritmo de planificación es apropiativo, el proceso en ejecución puede volver a la cola de preparados si agota su tiempo prefijado de ejecución (quantum) o si recibe una interrupción por la llegada de un proceso con más prioridad.
* **Ejecución → bloqueado**: si un proceso en ejecución necesita una operación de entrada/salida o alguno otro acontecimiento para continuar, pasa en el estado de bloqueado y libera la CPU.
* **Bloqueado → preparado**: si en un proceso bloqueado llega el suceso o finaliza la operación de entrada/salida que esperaba, entonces devuelve a la cola de procesos preparados.
* **Ejecución → finalizado**: si un proceso finaliza la ejecución de sus líneas de código o bien recibe una excepción por algún tipo de error grave, pasa a proceso finalizado y libera los recursos empleados.
